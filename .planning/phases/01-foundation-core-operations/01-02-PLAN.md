---
phase: 01-foundation-core-operations
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/ticket.rs
  - src/lib.rs
  - src/cli.rs
autonomous: true
requirements:
  - CRUD-01
  - CRUD-02
  - CRUD-03
  - CRUD-04
  - CRUD-05
  - STATE-01
  - STATE-02
  - STATE-03
  - CLI-04

must_haves:
  truths:
    - "rtik create --name 'Buy milk' --desc 'Grocery store' prints Created: #1 Buy milk"
    - "rtik get 1 prints compact paragraph with ID, name, status, description, and timestamps"
    - "rtik delete 1 prints Deleted: #1 Buy milk; rtik delete 999 prints error to stderr and exits 1"
    - "rtik list shows aligned ID/STATUS/NAME table, names truncated at 40 chars with ellipsis"
    - "rtik list --timestamps shows two extra columns for created_at and updated_at"
    - "rtik update 1 --status wip prints Updated: #1 Buy milk with status normalized to lowercase"
    - "rtik update 1 with no flags exits 1 with error about required fields"
  artifacts:
    - path: "src/ticket.rs"
      provides: "All CRUD functions: create_ticket, get_ticket, list_tickets, delete_ticket, update_ticket"
      exports: ["create_ticket", "get_ticket", "list_tickets", "delete_ticket", "update_ticket"]
    - path: "src/lib.rs"
      provides: "run() function dispatching all 5 subcommands with output formatting"
      contains: "Commands::Create"
  key_links:
    - from: "src/lib.rs"
      to: "src/ticket.rs"
      via: "ticket::create_ticket, get_ticket, list_tickets, delete_ticket, update_ticket calls"
      pattern: "ticket::(create|get|list|delete|update)_ticket"
    - from: "src/ticket.rs"
      to: "rusqlite::Connection"
      via: "execute, query_row, query_map for all CRUD ops"
      pattern: "conn\\.(execute|query_row|prepare)"
    - from: "src/lib.rs"
      to: "stdout"
      via: "println! for success output, eprintln! for errors"
      pattern: "println!"
---

<objective>
Implement all CRUD database functions and wire them to the CLI with correct output formatting.

Purpose: This plan delivers the complete user-facing functionality — after this, a user can
create, read, update, delete, and list tickets via the CLI with all specified output formats.
Output: Fully functional rtik binary satisfying all CRUD requirements.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-operations/01-RESEARCH.md
@.planning/phases/01-foundation-core-operations/01-CONTEXT.md
@.planning/phases/01-foundation-core-operations/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ticket CRUD database functions</name>
  <files>
    src/ticket.rs
  </files>
  <action>
Replace the stub src/ticket.rs with the full implementation of all CRUD database operations.

The Ticket struct and AppError enum from Plan 01 stay — add the five CRUD functions below them.

**create_ticket:**
```rust
pub fn create_ticket(conn: &Connection, name: &str, desc: &str) -> Result<i64, AppError> {
    conn.execute(
        "INSERT INTO tickets (name, description) VALUES (?1, ?2)",
        rusqlite::params![name, desc],
    )?;
    Ok(conn.last_insert_rowid())
}
```
Uses the SQL DEFAULT for created_at/updated_at (strftime UTC — avoids Pitfall 2 from RESEARCH.md).

**get_ticket:**
```rust
pub fn get_ticket(conn: &Connection, id: i64) -> Result<Ticket, AppError> {
    conn.query_row(
        "SELECT id, name, description, status, created_at, updated_at
         FROM tickets WHERE id = ?1",
        rusqlite::params![id],
        |row| Ok(Ticket {
            id:          row.get(0)?,
            name:        row.get(1)?,
            description: row.get(2)?,
            status:      row.get(3)?,
            created_at:  row.get(4)?,
            updated_at:  row.get(5)?,
        }),
    )
    .map_err(|e| match e {
        rusqlite::Error::QueryReturnedNoRows => AppError::NotFound(id),
        other => AppError::Db(other),
    })
}
```

**list_tickets:**
```rust
pub fn list_tickets(conn: &Connection) -> Result<Vec<Ticket>, AppError> {
    let mut stmt = conn.prepare(
        "SELECT id, name, description, status, created_at, updated_at
         FROM tickets ORDER BY id ASC"
    )?;
    let rows = stmt.query_map([], |row| Ok(Ticket {
        id:          row.get(0)?,
        name:        row.get(1)?,
        description: row.get(2)?,
        status:      row.get(3)?,
        created_at:  row.get(4)?,
        updated_at:  row.get(5)?,
    }))?;
    rows.collect::<rusqlite::Result<Vec<_>>>().map_err(AppError::Db)
}
```

**delete_ticket:**
```rust
pub fn delete_ticket(conn: &Connection, id: i64) -> Result<(), AppError> {
    match conn.execute("DELETE FROM tickets WHERE id = ?1", rusqlite::params![id])? {
        0 => Err(AppError::NotFound(id)),
        _ => Ok(()),
    }
}
```
Checking rows_affected is mandatory — Pitfall 3 in RESEARCH.md: silent success on missing ID.

**update_ticket — dynamic SQL with named parameters to avoid Pitfall 1:**

Use named parameters to avoid positional binding hell with optional fields:

```rust
pub fn update_ticket(
    conn: &Connection,
    id: i64,
    name: Option<&str>,
    desc: Option<&str>,
    status: Option<&str>,
) -> Result<String, AppError> {
    if name.is_none() && desc.is_none() && status.is_none() {
        return Err(AppError::NoUpdateFields);
    }
    let now = chrono_free_utc_now(); // see helper below
    let mut sets: Vec<String> = Vec::new();
    if name.is_some()   { sets.push("name = :name".to_string()); }
    if desc.is_some()   { sets.push("description = :desc".to_string()); }
    if status.is_some() { sets.push("status = :status".to_string()); }
    sets.push("updated_at = :now".to_string());

    let sql = format!("UPDATE tickets SET {} WHERE id = :id", sets.join(", "));
    let affected = conn.execute(
        &sql,
        rusqlite::named_params! {
            ":name":   name.unwrap_or(""),
            ":desc":   desc.unwrap_or(""),
            ":status": status.unwrap_or(""),
            ":now":    &now,
            ":id":     id,
        },
    )?;
    match affected {
        0 => Err(AppError::NotFound(id)),
        _ => {
            // Return updated ticket name for confirmation output
            let t = get_ticket(conn, id)?;
            Ok(t.name)
        }
    }
}
```

Note on named_params with unused params: rusqlite ignores named params that don't appear in the SQL.
So binding :name/:desc/:status even when not in SET is safe — they're simply unused.

**UTC timestamp helper (no chrono dependency):**
```rust
fn chrono_free_utc_now() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("time before epoch")
        .as_secs();
    let (y, mo, d, h, mi, s) = seconds_to_datetime(secs);
    format!("{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z", y, mo, d, h, mi, s)
}

fn seconds_to_datetime(secs: u64) -> (u64, u64, u64, u64, u64, u64) {
    let s = secs % 60;
    let mins = secs / 60;
    let mi = mins % 60;
    let hours = mins / 60;
    let h = hours % 24;
    let days = hours / 24;
    // Gregorian calendar calculation from epoch (1970-01-01)
    let (y, mo, d) = days_to_ymd(days);
    (y, mo, d, h, mi, s)
}

fn days_to_ymd(mut days: u64) -> (u64, u64, u64) {
    let mut year: u64 = 1970;
    loop {
        let leap = is_leap(year);
        let days_in_year = if leap { 366 } else { 365 };
        if days < days_in_year { break; }
        days -= days_in_year;
        year += 1;
    }
    let leap = is_leap(year);
    let month_days: [u64; 12] = [31, if leap { 29 } else { 28 }, 31, 30, 31, 30,
                                  31, 31, 30, 31, 30, 31];
    let mut month: u64 = 1;
    for &md in &month_days {
        if days < md { break; }
        days -= md;
        month += 1;
    }
    (year, month, days + 1)
}

fn is_leap(y: u64) -> bool {
    (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0)
}
```

This is pure std — no chrono needed. The RESEARCH.md recommends using strftime in SQL for
created_at (handled by the schema DEFAULT) and application-side for updated_at (this helper).

Add `use rusqlite::Connection;` at the top of the file.
  </action>
  <verify>
    `cargo check` exits 0 after adding all functions.
    All five functions are present: create_ticket, get_ticket, list_tickets, delete_ticket, update_ticket.
    update_ticket uses named_params! (not positional) to avoid parameter binding pitfalls.
  </verify>
  <done>
    src/ticket.rs has all 5 CRUD functions with correct error mapping.
    delete_ticket returns AppError::NotFound on 0 rows affected.
    update_ticket uses named params for dynamic SET clause.
    update_ticket validates NoUpdateFields before building SQL.
    `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CLI dispatch with output formatting</name>
  <files>
    src/lib.rs
    src/cli.rs
  </files>
  <action>
Replace the stub `run()` in src/lib.rs with the full dispatch implementation. All output formatting
happens here — ticket.rs only does data operations.

**Output format requirements (from CONTEXT.md — locked decisions):**

- `rtik create` → `Created: #1 Buy milk`
- `rtik get 1` →
  ```
  #1 Buy milk [todo]
  Go to grocery store
  Created: 2026-02-22 | Updated: 2026-02-22
  ```
  (date portion only from timestamp, not full ISO string)
- `rtik delete 1` → `Deleted: #1 Buy milk`
- `rtik update 1 --status wip` → `Updated: #1 Buy milk`
- `rtik list` → aligned table with ID/STATUS/NAME headers, names truncated at 40 chars with `...`
- `rtik list --timestamps` → adds CREATED and UPDATED columns

**Name truncation:** If name.len() > 40, show name[..37] + "..."

**Timestamp display in `get`:** Extract date from ISO timestamp `2026-02-22T10:00:00Z` → `2026-02-22`.
Split on 'T' and take the first part.

**List table alignment:** Use fixed-width format strings:
- ID: right-aligned, 4 chars wide: `{:>4}`
- STATUS: left-aligned, 9 chars wide: `{:<9}` (longest value "blocked" = 7 chars)
- NAME: left-aligned, truncated

Complete src/lib.rs:

```rust
pub mod cli;
pub mod db;
pub mod ticket;

use rusqlite::Connection;
use ticket::AppError;

pub fn run(cli: cli::Cli, conn: Connection) -> Result<(), AppError> {
    use cli::Commands;
    match cli.command {
        Commands::Create(args) => {
            let desc = args.desc.as_deref().unwrap_or("");
            let id = ticket::create_ticket(&conn, &args.name, desc)?;
            println!("Created: #{} {}", id, args.name);
        }
        Commands::Get { id } => {
            let t = ticket::get_ticket(&conn, id)?;
            let created_date = t.created_at.split('T').next().unwrap_or(&t.created_at);
            let updated_date = t.updated_at.split('T').next().unwrap_or(&t.updated_at);
            println!("#{} {} [{}]", t.id, t.name, t.status);
            if !t.description.is_empty() {
                println!("{}", t.description);
            }
            println!("Created: {} | Updated: {}", created_date, updated_date);
        }
        Commands::Update(args) => {
            let name = args.name.as_deref();
            let desc = args.desc.as_deref();
            let status = args.status.as_deref();
            if name.is_none() && desc.is_none() && status.is_none() {
                eprintln!("Error: at least one field required (--name, --desc, --status)");
                std::process::exit(1);
            }
            let ticket_name = ticket::update_ticket(&conn, args.id, name, desc, status)?;
            println!("Updated: #{} {}", args.id, ticket_name);
        }
        Commands::Delete { id } => {
            let t = ticket::get_ticket(&conn, id)?;
            ticket::delete_ticket(&conn, id)?;
            println!("Deleted: #{} {}", id, t.name);
        }
        Commands::List(args) => {
            let tickets = ticket::list_tickets(&conn)?;
            if tickets.is_empty() {
                println!("No tickets.");
                return Ok(());
            }
            if args.timestamps {
                println!("{:>4}  {:<9}  {:<40}  {:<10}  {:<10}", "ID", "STATUS", "NAME", "CREATED", "UPDATED");
                println!("{}", "-".repeat(80));
                for t in &tickets {
                    let name = truncate_name(&t.name, 40);
                    let created = t.created_at.split('T').next().unwrap_or("");
                    let updated = t.updated_at.split('T').next().unwrap_or("");
                    println!("{:>4}  {:<9}  {:<40}  {:<10}  {:<10}", t.id, t.status, name, created, updated);
                }
            } else {
                println!("{:>4}  {:<9}  {}", "ID", "STATUS", "NAME");
                println!("{}", "-".repeat(60));
                for t in &tickets {
                    let name = truncate_name(&t.name, 40);
                    println!("{:>4}  {:<9}  {}", t.id, t.status, name);
                }
            }
        }
    }
    Ok(())
}

fn truncate_name(name: &str, max_len: usize) -> String {
    if name.len() > max_len {
        format!("{}...", &name[..max_len - 3])
    } else {
        name.to_string()
    }
}
```

Note on Delete: we fetch the ticket name first (for the confirmation message), then delete. This is
intentional — it gives the user the name in the confirmation output as specified in CONTEXT.md.

Update src/cli.rs: The UpdateArgs struct needs to handle the "no flags" case. Clap itself won't
enforce this (it allows all-None), so the validation is done in run(). No changes needed to cli.rs
from Plan 01 unless the parse_status function needs to be made pub for use in tests.

Make parse_status pub in cli.rs:
```rust
pub fn parse_status(raw: &str) -> Result<String, String> {
    // ... same as Plan 01
}
```

Run `cargo build` and manually smoke test:
```bash
RTIK_DB=/tmp/test.db ./target/debug/rtik create --name "Buy milk" --desc "Grocery store"
RTIK_DB=/tmp/test.db ./target/debug/rtik get 1
RTIK_DB=/tmp/test.db ./target/debug/rtik list
RTIK_DB=/tmp/test.db ./target/debug/rtik update 1 --status WIP
RTIK_DB=/tmp/test.db ./target/debug/rtik list
RTIK_DB=/tmp/test.db ./target/debug/rtik delete 1
RTIK_DB=/tmp/test.db ./target/debug/rtik get 1   # should error
rm /tmp/test.db
```
  </action>
  <verify>
    `cargo build` exits 0.
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik create --name "Buy milk" --desc "Grocery store"` prints `Created: #1 Buy milk`
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik get 1` prints compact paragraph format with [todo]
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik update 1 --status WIP` prints `Updated: #1 Buy milk`
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik list` shows aligned table with wip (lowercase)
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik list --timestamps` shows CREATED/UPDATED columns
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik delete 1` prints `Deleted: #1 Buy milk`
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik get 999` prints error to stderr, exits 1
    `RTIK_DB=/tmp/smoke.db ./target/debug/rtik update 1` with no flags prints error, exits 1
    Run `rm /tmp/smoke.db` to clean up.
  </verify>
  <done>
    src/lib.rs has complete run() dispatch for all 5 commands.
    create outputs `Created: #{id} {name}`.
    get outputs compact paragraph: `#{id} {name} [{status}]`, description (if non-empty), `Created: {date} | Updated: {date}`.
    delete fetches name first, outputs `Deleted: #{id} {name}`.
    update validates at least one flag, outputs `Updated: #{id} {name}`.
    list shows aligned table; --timestamps adds CREATED/UPDATED columns.
    Names > 40 chars are truncated with `...`.
    Status stored as lowercase regardless of input case.
    All error messages go to stderr, process exits 1.
  </done>
</task>

</tasks>

<verification>
End-to-end smoke test sequence (run in order using RTIK_DB=/tmp/verify.db):
1. `rtik create --name "Test ticket" --desc "Some description"` → `Created: #1 Test ticket`
2. `rtik get 1` → shows paragraph format with [todo] status
3. `rtik create --name "Another ticket"` → `Created: #2 Another ticket` (desc optional)
4. `rtik list` → shows 2-row table sorted by ID
5. `rtik update 1 --status WIP --name "Updated name"` → `Updated: #1 Updated name`
6. `rtik get 1` → shows [wip] status (lowercase), updated_at changed
7. `rtik list --timestamps` → shows all 5 columns
8. `rtik delete 2` → `Deleted: #2 Another ticket`
9. `rtik get 2` → error on stderr, exit code 1
10. `echo $?` → 1
11. `rtik update 1` → error about required fields, exit code 1
12. `rm /tmp/verify.db`
</verification>

<success_criteria>
- All 5 CRUD operations work correctly via CLI
- Output formats match CONTEXT.md specifications exactly
- Status is case-insensitive on input, stored/displayed as lowercase
- Missing ticket ID returns error to stderr and exits 1
- No-flag update returns error to stderr and exits 1
- List table columns are aligned with headers
- Name truncation at 40 chars with ellipsis
- `--timestamps` flag adds CREATED/UPDATED columns to list
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-operations/01-02-SUMMARY.md`
</output>
