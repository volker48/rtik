---
phase: 01-foundation-core-operations
plan: 03
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified:
  - tests/integration.rs
  - Cargo.toml
autonomous: true
requirements:
  - STATE-01
  - STATE-02
  - STATE-03
  - STATE-05
  - CLI-04
  - CLI-05
  - CLI-06

must_haves:
  truths:
    - "cargo test passes with all integration tests green"
    - "cargo build --release produces target/release/rtik as a single binary"
    - "rtik list | head -1 does not panic or print a broken pipe error"
    - "AppError::NotFound produces a clear message with the ticket ID"
    - "Status validation rejects invalid values; accepts todo/wip/blocked/done case-insensitively"
    - "created_at is set on INSERT and does not change on UPDATE; updated_at changes on UPDATE"
  artifacts:
    - path: "tests/integration.rs"
      provides: "Integration tests covering create/get/update/delete/list and error cases"
      min_lines: 80
  key_links:
    - from: "tests/integration.rs"
      to: "rtik::db::open_connection"
      via: "in-memory or tempfile DB for test isolation"
      pattern: "open_connection"
    - from: "tests/integration.rs"
      to: "rtik::ticket"
      via: "direct function calls (not subprocess) for fast test cycles"
      pattern: "ticket::(create|get|update|delete|list)_ticket"
---

<objective>
Write integration tests covering the domain logic and verify the binary meets all CLI requirements.

Purpose: TDD validates the correctness of status validation, timestamp behavior, and error handling
with defined inputs and expected outputs. The binary build check confirms TECH-05 (zero runtime deps).
Output: Passing test suite; release binary ready to ship.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-operations/01-RESEARCH.md
@.planning/phases/01-foundation-core-operations/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-operations/01-02-SUMMARY.md
</context>

<feature>
  <name>Integration tests for CRUD correctness and error handling</name>
  <files>tests/integration.rs</files>
  <behavior>
    Test cases (input → expected output):

    CRUD-01/STATE-05: create_ticket("Buy milk", "Grocery") → returns Ok(1), second create returns Ok(2)
    CRUD-02: get_ticket(id=1) → returns Ok(Ticket { id=1, name="Buy milk", status="todo", ... })
    CRUD-02: get_ticket(id=999) → returns Err(AppError::NotFound(999))
    STATE-01: create_ticket returns status "todo" by default
    STATE-01: update_ticket with status="WIP" stores as "wip" (lowercase)
    STATE-02: created_at is a non-empty ISO string on creation
    STATE-03: updated_at changes after update_ticket call
    STATE-03: created_at does NOT change after update_ticket call
    CRUD-03: update_ticket with no fields → Err(AppError::NoUpdateFields)
    CRUD-03: update_ticket with name="New name" → Ok("New name")
    CRUD-04: delete_ticket(id=1) → Ok(()), subsequent get returns Err(NotFound)
    CRUD-04: delete_ticket(id=999) → Err(AppError::NotFound(999))
    CRUD-05: list_tickets on empty DB → Ok(vec![])
    CRUD-05: list_tickets with 2 tickets → Ok(vec![t1, t2]) sorted by id ASC
  </behavior>
  <implementation>
    Use rusqlite Connection::open_in_memory() for test isolation — each test gets a fresh DB.
    Call rtik::db::open_connection() on the in-memory connection after open to run migrations.
    Since open_connection takes a path, use a tempfile for tests that need real file-based WAL.
    Call ticket functions directly (no subprocess) for fast, deterministic tests.

    TDD cycle:
    RED: Write all tests first — they fail because no test file exists yet.
    GREEN: Tests pass because ticket.rs functions are already implemented (Plan 02).
    REFACTOR: Fix any issues found — the tests reveal the correctness of Plan 02's implementation.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Write integration tests (RED then GREEN)</name>
  <files>
    tests/integration.rs
    Cargo.toml
  </files>
  <action>
First, add the `tempfile` dev-dependency to Cargo.toml:
```toml
[dev-dependencies]
tempfile = "3"
```

Then create `tests/integration.rs` with a full integration test suite. Each test uses an isolated
tempfile database to avoid test order dependencies and to exercise the real WAL-mode open path.

The helper function keeps the TempPath alive alongside the connection so the file is not deleted
while the connection is open:

```rust
fn open_test_db() -> (rusqlite::Connection, tempfile::TempPath) {
    let tmp = tempfile::NamedTempFile::new().expect("tempfile");
    let path = tmp.path().to_path_buf();
    let conn = rtik::db::open_connection(&path).expect("open_connection");
    (conn, tmp.into_temp_path())
}
```

Write the test cases. Use the TDD RED cycle: write tests FIRST, run `cargo test` to see them fail
(they won't compile without tempfile, which will be the first red), add the dev-dependency, then
run again — tests should now pass since the implementations exist from Plan 02.

```rust
use rtik::{db, ticket};

fn open_test_db() -> (rusqlite::Connection, tempfile::TempPath) {
    let tmp = tempfile::NamedTempFile::new().expect("tempfile");
    let path = tmp.path().to_path_buf();
    let conn = db::open_connection(&path).expect("open_connection");
    (conn, tmp.into_temp_path())
}

#[test]
fn create_ticket_returns_incrementing_ids() {
    let (conn, _tmp) = open_test_db();
    let id1 = ticket::create_ticket(&conn, "First", "").unwrap();
    let id2 = ticket::create_ticket(&conn, "Second", "").unwrap();
    assert_eq!(id1, 1);
    assert_eq!(id2, 2);
}

#[test]
fn create_ticket_defaults_to_todo_status() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Buy milk", "Grocery").unwrap();
    let t = ticket::get_ticket(&conn, id).unwrap();
    assert_eq!(t.status, "todo");
    assert_eq!(t.name, "Buy milk");
    assert_eq!(t.description, "Grocery");
}

#[test]
fn get_ticket_not_found() {
    let (conn, _tmp) = open_test_db();
    let result = ticket::get_ticket(&conn, 999);
    assert!(matches!(result, Err(ticket::AppError::NotFound(999))));
}

#[test]
fn delete_ticket_removes_it() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Temp", "").unwrap();
    ticket::delete_ticket(&conn, id).unwrap();
    assert!(matches!(ticket::get_ticket(&conn, id), Err(ticket::AppError::NotFound(_))));
}

#[test]
fn delete_nonexistent_ticket_returns_not_found() {
    let (conn, _tmp) = open_test_db();
    let result = ticket::delete_ticket(&conn, 999);
    assert!(matches!(result, Err(ticket::AppError::NotFound(999))));
}

#[test]
fn list_tickets_empty_db() {
    let (conn, _tmp) = open_test_db();
    let tickets = ticket::list_tickets(&conn).unwrap();
    assert!(tickets.is_empty());
}

#[test]
fn list_tickets_sorted_by_id() {
    let (conn, _tmp) = open_test_db();
    ticket::create_ticket(&conn, "Alpha", "").unwrap();
    ticket::create_ticket(&conn, "Beta", "").unwrap();
    let tickets = ticket::list_tickets(&conn).unwrap();
    assert_eq!(tickets.len(), 2);
    assert!(tickets[0].id < tickets[1].id);
    assert_eq!(tickets[0].name, "Alpha");
}

#[test]
fn update_ticket_status_normalized_to_lowercase() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Task", "").unwrap();
    ticket::update_ticket(&conn, id, None, None, Some("WIP")).unwrap();
    let t = ticket::get_ticket(&conn, id).unwrap();
    assert_eq!(t.status, "wip");
}

#[test]
fn update_ticket_no_fields_returns_error() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Task", "").unwrap();
    let result = ticket::update_ticket(&conn, id, None, None, None);
    assert!(matches!(result, Err(ticket::AppError::NoUpdateFields)));
}

#[test]
fn update_ticket_nonexistent_returns_not_found() {
    let (conn, _tmp) = open_test_db();
    let result = ticket::update_ticket(&conn, 999, Some("name"), None, None);
    assert!(matches!(result, Err(ticket::AppError::NotFound(999))));
}

#[test]
fn created_at_preserved_updated_at_changes_on_update() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Task", "").unwrap();
    let before = ticket::get_ticket(&conn, id).unwrap();

    // Wait 1 second to ensure timestamp difference
    std::thread::sleep(std::time::Duration::from_secs(1));

    ticket::update_ticket(&conn, id, Some("New name"), None, None).unwrap();
    let after = ticket::get_ticket(&conn, id).unwrap();

    assert_eq!(before.created_at, after.created_at, "created_at should not change");
    assert_ne!(before.updated_at, after.updated_at, "updated_at should change after update");
}

#[test]
fn update_ticket_partial_update_preserves_other_fields() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Original", "My desc").unwrap();
    ticket::update_ticket(&conn, id, Some("Renamed"), None, None).unwrap();
    let t = ticket::get_ticket(&conn, id).unwrap();
    assert_eq!(t.name, "Renamed");
    assert_eq!(t.description, "My desc"); // unchanged
    assert_eq!(t.status, "todo");         // unchanged
}

#[test]
fn created_at_is_iso8601_utc_format() {
    let (conn, _tmp) = open_test_db();
    let id = ticket::create_ticket(&conn, "Task", "").unwrap();
    let t = ticket::get_ticket(&conn, id).unwrap();
    // Should match YYYY-MM-DDTHH:MM:SSZ
    assert!(t.created_at.contains('T'), "created_at should be ISO 8601 with T separator");
    assert!(t.created_at.ends_with('Z'), "created_at should end with Z (UTC)");
}
```

Run the RED cycle:
```bash
cargo test 2>&1 | head -30
```
Expected: compilation failure due to missing `tempfile` dev-dependency (before adding it).

After adding the dev-dependency, run GREEN cycle:
```bash
cargo test
```
All tests should pass. If any fail, debug the ticket.rs implementation from Plan 02.

Note: The `created_at_preserved_updated_at_changes_on_update` test sleeps 1 second — this is
intentional to ensure the UTC timestamp changes between create and update.
  </action>
  <verify>
    `cargo test` exits 0 with all tests passing.
    Output shows at least 12 test functions run and pass.
    The `created_at_preserved` test passes, confirming timestamp behavior is correct.
    The `update_ticket_partial_update_preserves_other_fields` test passes, confirming the dynamic
    param binding in update_ticket does not overwrite unrelated fields with empty strings.
  </verify>
  <done>
    tests/integration.rs exists with 12+ test cases.
    Cargo.toml has `tempfile = "3"` under [dev-dependencies].
    All tests pass via `cargo test`.
    Tests cover: CRUD correctness, status normalization, error cases (NotFound, NoUpdateFields),
    timestamp behavior (created_at unchanged, updated_at updated), and partial update preservation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Release build verification and broken-pipe test</name>
  <files>
    Cargo.toml
  </files>
  <action>
Verify the release binary meets TECH-05 and CLI-06 requirements.

**TECH-05 — single binary, zero runtime dependencies:**

```bash
cargo build --release
```

Confirm the binary exists and check its dynamic dependencies:
```bash
ls -lh target/release/rtik
# On macOS:
otool -L target/release/rtik
# On Linux:
ldd target/release/rtik
```

The only dynamic dependencies should be system libraries (libSystem on macOS, libc/libpthread on
Linux). There should be NO reference to libsqlite3 — it must be statically linked via the `bundled`
feature. If libsqlite3 appears as a dynamic dep, the `bundled` feature is missing from Cargo.toml.

**CLI-06 — broken pipe graceful handling:**

Test that piping to `head` does not panic:
```bash
RTIK_DB=/tmp/piptest.db target/release/rtik create --name "ticket 1" --desc "" 2>&1
RTIK_DB=/tmp/piptest.db target/release/rtik create --name "ticket 2" --desc "" 2>&1
RTIK_DB=/tmp/piptest.db target/release/rtik list | head -1
echo "exit code: $?"
rm /tmp/piptest.db
```

Expected: outputs the header line, exits cleanly. Without `sigpipe::reset()`, this would panic
with "failed printing to stdout: Broken pipe (os error 32)".

**CLI-05 — exit codes:**

```bash
target/release/rtik; echo "no-args exit: $?"       # should be 2
RTIK_DB=/tmp/ec.db target/release/rtik get 999; echo "not-found exit: $?"  # should be 1
rm -f /tmp/ec.db
```

If the broken-pipe test fails (panic on pipe), verify `sigpipe::reset()` is the first statement
in src/main.rs before any other calls. This is the fix for Rust's default SIGPIPE ignore behavior
(RESEARCH.md Pattern 6, Pitfall section).

If any release build issues arise with the `bundled` feature (compilation error about missing
cc/cmake), ensure Xcode command line tools or build-essential is installed — the bundled feature
compiles SQLite from source. This is expected on first build and takes ~30 seconds.
  </action>
  <verify>
    `cargo build --release` exits 0.
    `target/release/rtik --version` prints version string.
    `otool -L target/release/rtik` (macOS) or `ldd target/release/rtik` (Linux) shows NO libsqlite3.
    `RTIK_DB=/tmp/p.db target/release/rtik list | head -1` exits cleanly without panic.
    `target/release/rtik 2>&1; echo $?` prints usage and exits with 2.
    `RTIK_DB=/tmp/p.db target/release/rtik get 999 2>&1; echo $?` shows error and exits with 1.
    Run `rm -f /tmp/p.db` to clean up.
  </verify>
  <done>
    Release binary exists at target/release/rtik.
    No libsqlite3 dynamic dependency — fully self-contained binary.
    Broken pipe (head pipe) exits cleanly — no panic.
    Exit code 2 for usage errors, exit code 1 for runtime errors (ticket not found, DB error).
  </done>
</task>

</tasks>

<verification>
Final phase verification:
1. `cargo test` — all tests green
2. `cargo build --release` — clean build
3. `target/release/rtik --help` — usage printed, exit 0
4. Full CRUD smoke test with RTIK_DB env var (see Plan 02 verification)
5. Broken pipe: `RTIK_DB=/tmp/final.db target/release/rtik list | head -1` — no panic
6. `rm -f /tmp/final.db`
</verification>

<success_criteria>
- `cargo test` passes with 12+ test cases
- `cargo build --release` succeeds
- Release binary has no libsqlite3 dynamic dependency
- Pipe to head exits cleanly (sigpipe handled)
- Exit codes: 0 success, 1 error, 2 usage
- All 6 phase success criteria from ROADMAP.md are met:
  1. Create ticket returns unique ID
  2. Get ticket shows all fields
  3. Update and delete work
  4. List shows status, timestamps (with flag), IDs
  5. Helpful error messages, correct exit codes
  6. SQLite persists between invocations with WAL mode
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-operations/01-03-SUMMARY.md`
</output>
