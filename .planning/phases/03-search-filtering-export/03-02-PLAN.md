---
phase: 03-search-filtering-export
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ticket.rs
autonomous: true
requirements:
  - QUERY-01
  - QUERY-02
  - QUERY-03
  - QUERY-04
  - QUERY-05
  - QUERY-06
  - EXPORT-01
  - EXPORT-02
  - EXPORT-03
  - EXPORT-04

must_haves:
  truths:
    - "list_tickets_filtered accepts a ListFilter and returns only matching tickets"
    - "Status filter matches exact stored value (case-sensitive pass-through)"
    - "Claimed/unclaimed filter uses IS NOT NULL / IS NULL on claimed_by"
    - "Claimer filter matches claimed_by exactly"
    - "Each --search term must appear in name OR description (case-insensitive LOWER LIKE)"
    - "Multiple search terms AND-composed: all terms must match"
    - "TicketExport struct carries id, name, description, status, claimed_by, dependencies"
    - "format_export_text produces one-line: T-{id} [{status}] {name} deps:T-x,T-y"
  artifacts:
    - path: "src/ticket.rs"
      provides: "ListFilter struct, list_tickets_filtered fn, TicketExport struct, format_export_text fn"
      contains: "pub struct ListFilter"
    - path: "src/ticket.rs"
      provides: "Serialize derive on TicketExport"
      contains: "#[derive(Serialize)]"
  key_links:
    - from: "src/lib.rs Commands::List handler"
      to: "ticket::list_tickets_filtered"
      via: "called with ListFilter built from ListArgs"
      pattern: "list_tickets_filtered"
    - from: "src/lib.rs Commands::Export handler"
      to: "ticket::TicketExport"
      via: "serde_json::to_string_pretty or format_export_text"
      pattern: "TicketExport"
---

<objective>
Add filtering/search infrastructure and export types to ticket.rs: ListFilter struct, list_tickets_filtered function, TicketExport struct with serde::Serialize, and format_export_text helper.

Purpose: All query and export business logic lives in ticket.rs (library layer). lib.rs wiring (Plan 03) depends on these types and functions existing.
Output: ticket.rs with list_tickets_filtered (dynamic SQL WHERE), ListFilter struct, TicketExport struct, format_export_text function.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/ticket.rs
@.planning/phases/03-search-filtering-export/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ListFilter struct and list_tickets_filtered to ticket.rs</name>
  <files>src/ticket.rs</files>
  <action>
    Add the following to src/ticket.rs (after the existing pub structs, before or after the existing list_tickets function):

    **ListFilter struct:**
    ```rust
    pub struct ListFilter {
        pub status: Option<String>,
        /// None = no filter, Some(true) = claimed only, Some(false) = unclaimed only
        pub claimed: Option<bool>,
        pub claimer: Option<String>,
        /// Each term must appear in name OR description (AND-composed across terms, case-insensitive)
        pub search: Vec<String>,
    }
    ```

    **list_tickets_filtered function** — builds a dynamic WHERE clause:
    - Use positional `?` placeholders with `Vec<Box<dyn rusqlite::types::ToSql>>`. Do NOT use named params (they don't work with dynamic param counts).
    - Status condition: `status = ?` (exact match, pass-through — no validation, invalid values return empty results)
    - Claimed condition:
      - `Some(true)` → `claimed_by IS NOT NULL` (no param)
      - `Some(false)` → `claimed_by IS NULL` (no param)
    - Claimer condition: `claimed_by = ?` (exact match string)
    - Per search term: `(LOWER(name) LIKE ? OR LOWER(description) LIKE ?)` with pattern `format!("%{}%", term.to_lowercase())` — push the pattern twice (once for name, once for description)
    - Join all conditions with ` AND `
    - SQL: `SELECT id, name, description, status, claimed_by, claimed_at, block_reason, created_at, updated_at FROM tickets {WHERE clause} ORDER BY id ASC`
    - Return `Result<Vec<Ticket>, AppError>` using the existing `Ticket` struct (same mapping as `list_tickets`)

    The function signature:
    ```rust
    pub fn list_tickets_filtered(conn: &Connection, filter: &ListFilter) -> Result<Vec<Ticket>, AppError>
    ```

    After adding, keep the existing `list_tickets` function as-is (tests depend on it). It can be implemented as a wrapper: `list_tickets_filtered(conn, &ListFilter { status: None, claimed: None, claimer: None, search: vec![] })` — or left as its own SQL query. Either approach is fine; the wrapper approach removes duplication.

    Run `cargo check` after this task.
  </action>
  <verify>cargo check --quiet 2>&amp;1 | grep -v warning; grep -q 'pub struct ListFilter' src/ticket.rs; grep -q 'pub fn list_tickets_filtered' src/ticket.rs</verify>
  <done>ListFilter struct and list_tickets_filtered function compile cleanly. list_tickets still exists (or is a wrapper). Dynamic WHERE builder uses positional params.</done>
</task>

<task type="auto">
  <name>Task 2: Add TicketExport struct and format_export_text to ticket.rs</name>
  <files>src/ticket.rs</files>
  <action>
    Add the following to src/ticket.rs:

    **TicketExport struct** — add `use serde::Serialize;` at the top of the file (or with the existing use statements), then:
    ```rust
    #[derive(Serialize)]
    pub struct TicketExport {
        pub id: i64,
        pub name: String,
        pub description: String,
        pub status: String,
        pub claimed_by: Option<String>,
        pub dependencies: Vec<i64>,
    }
    ```

    **tickets_to_export function** — builds Vec<TicketExport> from filtered results by enriching each Ticket with its dependency IDs via list_deps:
    ```rust
    pub fn tickets_to_export(conn: &Connection, filter: &ListFilter) -> Result<Vec<TicketExport>, AppError> {
        let tickets = list_tickets_filtered(conn, filter)?;
        tickets
            .into_iter()
            .map(|t| {
                let deps = list_deps(conn, t.id)?;
                Ok(TicketExport {
                    id: t.id,
                    name: t.name,
                    description: t.description,
                    status: t.status,
                    claimed_by: t.claimed_by,
                    dependencies: deps.forward,
                })
            })
            .collect()
    }
    ```

    Note: This uses the N+1 approach (one list_deps call per ticket) per RESEARCH.md recommendation. The tool operates at small scale; this is acceptable.

    **format_export_text function** — formats one TicketExport as a single line:
    - Format: `T-{id} [{status}] {name}{deps_suffix}`
    - deps_suffix: if dependencies is empty → no suffix; if non-empty → ` deps:T-{d1},T-{d2},...`
    - Example: `T-1 [todo] Fix auth bug deps:T-2,T-3`
    - Example (no deps): `T-4 [done] Write tests`
    - The `T-{id}` prefix is the export format; interactive commands keep `#{id}` (no change to those)

    ```rust
    pub fn format_export_text(t: &TicketExport) -> String {
        let deps_suffix = if t.dependencies.is_empty() {
            String::new()
        } else {
            let dep_ids = t.dependencies.iter().map(|d| format!("T-{}", d)).collect::<Vec<_>>().join(",");
            format!(" deps:{}", dep_ids)
        };
        format!("T-{} [{}] {}{}", t.id, t.status, t.name, deps_suffix)
    }
    ```

    Run `cargo check` after this task.
  </action>
  <verify>cargo check --quiet 2>&amp;1 | grep -v warning; grep -q '#\[derive(Serialize)\]' src/ticket.rs; grep -q 'pub struct TicketExport' src/ticket.rs; grep -q 'pub fn format_export_text' src/ticket.rs; grep -q 'pub fn tickets_to_export' src/ticket.rs</verify>
  <done>TicketExport struct compiles with #[derive(Serialize)]. tickets_to_export and format_export_text functions compile cleanly. format_export_text produces T-{id} [status] name format.</done>
</task>

</tasks>

<verification>
Run:
  cargo check --quiet

Expected: zero errors.

Verify public surface:
  grep -n 'pub struct ListFilter\|pub fn list_tickets_filtered\|pub struct TicketExport\|pub fn tickets_to_export\|pub fn format_export_text' src/ticket.rs

Expected: all 5 identifiers present.

Verify Serialize import:
  grep -n 'use serde' src/ticket.rs

Expected: serde::Serialize imported.
</verification>

<success_criteria>
- `cargo check` passes with zero errors
- ListFilter struct is pub with 4 fields (status, claimed, claimer, search)
- list_tickets_filtered builds dynamic WHERE using positional params
- TicketExport derives Serialize with 6 fields including dependencies: Vec&lt;i64&gt;
- tickets_to_export uses N+1 list_deps calls per ticket
- format_export_text produces `T-{id} [{status}] {name}` with optional ` deps:T-x,T-y` suffix
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-filtering-export/03-02-SUMMARY.md`
</output>
