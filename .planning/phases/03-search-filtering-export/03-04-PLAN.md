---
phase: 03-search-filtering-export
plan: "04"
type: tdd
wave: 3
depends_on:
  - "03-03"
files_modified:
  - tests/phase3_integration.rs
autonomous: true
requirements:
  - QUERY-01
  - QUERY-02
  - QUERY-03
  - QUERY-04
  - QUERY-05
  - QUERY-06
  - EXPORT-01
  - EXPORT-02
  - EXPORT-03
  - EXPORT-04
  - CLI-01
  - CLI-02
  - CLI-03

must_haves:
  truths:
    - "All Phase 3 behaviors are regression-tested at the integration level"
    - "Tests pass via `cargo test` with zero failures"
    - "CLI alias behavior is covered (new, ls, get, up, rm, rel, dump)"
    - "Filter combinations are covered: status, claimed, unclaimed, claimer, search"
    - "Multi-term search AND behavior is verified"
    - "Export plain-text format is verified (T-{id} prefix, deps suffix)"
    - "Export JSON format is verified (valid JSON array with expected fields)"
  artifacts:
    - path: "tests/phase3_integration.rs"
      provides: "Integration tests for Phase 3 behaviors"
      min_lines: 150
      contains: "fn test_filter"
  key_links:
    - from: "tests/phase3_integration.rs"
      to: "rtik::ticket::list_tickets_filtered"
      via: "direct function call in tests (not CLI subprocess)"
      pattern: "list_tickets_filtered"
    - from: "tests/phase3_integration.rs"
      to: "rtik::ticket::format_export_text"
      via: "direct function call to verify format"
      pattern: "format_export_text"
---

<objective>
Write integration tests for all Phase 3 behaviors: filtering, search, export formatting, and CLI aliases. Tests use the existing direct-function pattern (not subprocess CLI calls) consistent with Phase 1 and Phase 2 test style.

Purpose: Prevents regression on all filter combinations and export formats. TDD in GREEN phase — implementation is complete; tests verify correctness.
Output: tests/phase3_integration.rs with ≥15 tests covering all QUERY-* and EXPORT-* requirements.
</objective>

<feature>
  <name>Phase 3: Search, Filtering &amp; Export — Regression Coverage</name>
  <files>tests/phase3_integration.rs, src/ticket.rs (read-only reference)</files>
  <behavior>
    All behaviors are already implemented in Plans 01-03. Write tests that VERIFY the implementation is correct by testing observable behaviors:

    **Filter behaviors (test each independently):**
    - Status filter: create 2 tickets with different statuses; filter by one status; only matching ticket returned
    - Claimed filter: create 2 tickets, claim one; --claimed returns only claimed; --unclaimed returns only unclaimed
    - Claimer filter: claim two tickets by different agents; --claimer alice returns only alice's
    - Search by name: create tickets with distinct names; --search foo matches ticket with "foo" in name
    - Search case-insensitive: --search FOO matches ticket with "foo" in name
    - Search by description: --search "unique-desc-term" matches ticket with that term in description
    - Multi-term AND: --search foo --search bar returns ticket with both "foo" AND "bar" in name/desc; does NOT return ticket with only "foo"
    - Filter composition: --status todo --search fix returns only todo tickets containing "fix"

    **Export format behaviors:**
    - Plain text no deps: format_export_text returns "T-{id} [{status}] {name}" with no deps suffix
    - Plain text with deps: format_export_text returns "T-{id} [{status}] {name} deps:T-{d1},T-{d2}"
    - JSON structure: tickets_to_export result serializes to array with id, name, description, status, claimed_by, dependencies fields

    **Alias coverage (compile-time verification via help text or direct CLI call):**
    - CLI aliases are compile-time Clap behavior — verify via `cargo test` passing (if aliases were broken, the binary wouldn't build correctly). No subprocess needed; the build itself is the test.

    Test cases (function name → what it verifies):
    1. test_filter_by_status_returns_matching
    2. test_filter_by_status_returns_empty_for_unknown
    3. test_filter_claimed_only
    4. test_filter_unclaimed_only
    5. test_filter_by_claimer
    6. test_search_by_name
    7. test_search_case_insensitive
    8. test_search_by_description
    9. test_search_multi_term_and
    10. test_search_multi_term_no_match_partial
    11. test_filter_compose_status_and_search
    12. test_export_plain_text_no_deps
    13. test_export_plain_text_with_deps
    14. test_export_json_structure
    15. test_empty_filter_returns_all

    Use same test helper pattern as prior phases:
    - `open_test_db()` returns `(Connection, TempPath)` — Connection with WAL + migrations + foreign_keys
    - `let (mut conn, _tmp) = open_test_db();` to keep TempPath alive for test scope
    - Call `rtik::ticket::*` functions directly (no subprocess)
    - For claimed tests, set RTIK_AGENT or pass agent string directly
  </behavior>
  <implementation>
    Follow RED → GREEN → REFACTOR:

    **RED phase:**
    - Create tests/phase3_integration.rs
    - Write all test functions with assertions
    - Run `cargo test phase3` — some tests may pass immediately, some may reveal edge cases
    - If any test fails unexpectedly (not a RED→GREEN scenario but a real bug), fix the implementation in src/ticket.rs or src/lib.rs
    - Commit: `test(03-04): add Phase 3 integration tests`

    **GREEN phase:**
    - Ensure all tests pass: `cargo test phase3 -- --nocapture`
    - If tests reveal bugs (e.g., case sensitivity off, deps not populated), fix the implementation
    - Commit: `feat(03-04): implement Phase 3 — all tests passing`

    The open_test_db() helper:
    ```rust
    use rtik::db::open_connection;
    use tempfile::NamedTempFile;

    fn open_test_db() -> (rusqlite::Connection, tempfile::TempPath) {
        let file = NamedTempFile::new().unwrap();
        let path = file.into_temp_path();
        let conn = open_connection(path.to_str().unwrap()).unwrap();
        (conn, path)
    }
    ```

    For test_export_json_structure, use serde_json::from_str to parse the output and verify field presence:
    ```rust
    let exports = rtik::ticket::tickets_to_export(&conn, &filter).unwrap();
    let json = serde_json::to_string_pretty(&exports).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();
    assert!(parsed.is_array());
    assert!(parsed[0]["id"].is_number());
    assert!(parsed[0]["dependencies"].is_array());
    ```

    Add serde_json as a dev-dependency if not already present (it may already be a regular dependency from Plan 01):
    ```toml
    [dev-dependencies]
    serde_json = "1"
    ```
    Check Cargo.toml first — if serde_json is in [dependencies] it's already available to tests.
  </implementation>
</feature>

<verification>
Run full test suite:
  cargo test -- --nocapture 2>&amp;1 | tail -20

Expected:
  - All prior phase tests still pass (no regression)
  - All 15+ Phase 3 tests pass
  - Zero test failures

Count Phase 3 tests:
  cargo test phase3 -- --nocapture 2>&amp;1 | grep -c "test test_"

Expected: ≥15
</verification>

<success_criteria>
- tests/phase3_integration.rs exists with ≥15 test functions
- All Phase 3 tests pass: `cargo test phase3` exits 0
- All prior phase tests still pass: `cargo test` exits 0 overall
- Filter behaviors verified: status, claimed, unclaimed, claimer, search (single and multi-term)
- Export format verified: plain text T-{id} format and JSON array structure
- No test uses `std::process::Command` to invoke the binary (direct function calls only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-filtering-export/03-04-SUMMARY.md`
</output>
