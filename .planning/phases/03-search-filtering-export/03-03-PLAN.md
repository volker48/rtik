---
phase: 03-search-filtering-export
plan: "03"
type: execute
wave: 2
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - src/lib.rs
autonomous: true
requirements:
  - QUERY-01
  - QUERY-02
  - QUERY-03
  - QUERY-04
  - QUERY-05
  - QUERY-06
  - EXPORT-01
  - EXPORT-02
  - EXPORT-03
  - EXPORT-04
  - CLI-01
  - CLI-02
  - CLI-03

must_haves:
  truths:
    - "rtik ls --status todo returns only todo tickets"
    - "rtik ls --unclaimed returns only unclaimed tickets"
    - "rtik ls --claimer alice returns only tickets claimed by alice"
    - "rtik ls --search foo returns tickets where name or description contains 'foo' (case-insensitive)"
    - "rtik ls --search foo --search bar returns tickets matching both terms"
    - "rtik export prints one line per ticket in T-{id} [{status}] {name} format"
    - "rtik export --json prints a JSON array"
    - "rtik dump works as alias for export"
    - "Conflicting --claimed and --unclaimed together produces an error message"
  artifacts:
    - path: "src/lib.rs"
      provides: "build_filter helper, updated List handler, Export match arm"
      contains: "Commands::Export"
    - path: "src/lib.rs"
      provides: "Error for conflicting --claimed --unclaimed"
      contains: "claimed && args.unclaimed"
  key_links:
    - from: "src/lib.rs Commands::List"
      to: "ticket::list_tickets_filtered"
      via: "build_filter(args) -> ListFilter passed to list_tickets_filtered"
      pattern: "list_tickets_filtered"
    - from: "src/lib.rs Commands::Export"
      to: "ticket::tickets_to_export"
      via: "same build_filter called with ExportArgs"
      pattern: "tickets_to_export"
    - from: "src/lib.rs Commands::Export"
      to: "serde_json::to_string_pretty"
      via: "--json flag branch"
      pattern: "to_string_pretty"
---

<objective>
Wire the filter flags and export command in lib.rs: replace list_tickets call with list_tickets_filtered, add build_filter helpers for ListArgs and ExportArgs, add Commands::Export match arm with plain-text and JSON output branches.

Purpose: Connects the CLI surface (Plan 01) and library logic (Plan 02) into working end-to-end behavior.
Output: Updated lib.rs with filter wiring on List command, build_filter private helpers, and Export match arm.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib.rs
@src/cli.rs
@src/ticket.rs
@.planning/phases/03-search-filtering-export/03-01-SUMMARY.md
@.planning/phases/03-search-filtering-export/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire filter flags into the List command handler</name>
  <files>src/lib.rs</files>
  <action>
    In src/lib.rs, update the Commands::List match arm and add a private build_filter_from_list helper:

    **Add build_filter_from_list private function** (after the existing run() function or near the bottom private helpers):
    ```rust
    fn build_filter_from_list(args: &cli::ListArgs) -> Result<ticket::ListFilter, ticket::AppError> {
        if args.claimed && args.unclaimed {
            eprintln!("Error: --claimed and --unclaimed are mutually exclusive");
            std::process::exit(1);
        }
        let claimed = if args.claimed {
            Some(true)
        } else if args.unclaimed {
            Some(false)
        } else {
            None
        };
        Ok(ticket::ListFilter {
            status: args.status.clone(),
            claimed,
            claimer: args.claimer.clone(),
            search: args.search.clone(),
        })
    }
    ```

    Note: Using `process::exit(1)` here is consistent with the existing pattern in the codebase for usage errors (e.g., the Update handler already does this). An AppError variant would also work but adds churn.

    **Update Commands::List match arm** — replace the `ticket::list_tickets(&conn)?` call with:
    ```rust
    Commands::List(args) => {
        let filter = build_filter_from_list(&args)?;
        let tickets = ticket::list_tickets_filtered(&conn, &filter)?;
        if tickets.is_empty() {
            println!("No tickets.");
            return Ok(());
        }
        let dep_counts = load_dep_counts(&conn)?;
        // ... rest of the existing table rendering code unchanged ...
    }
    ```

    The table rendering code (timestamps branch and non-timestamps branch) remains identical — just swap the data source. The dep_counts HashMap and format_name_with_deps calls are unchanged.

    Run `cargo check` after this task.
  </action>
  <verify>cargo check --quiet 2>&amp;1 | grep -v warning; grep -q 'list_tickets_filtered' src/lib.rs; grep -q 'build_filter_from_list' src/lib.rs</verify>
  <done>List command uses list_tickets_filtered. build_filter_from_list converts ListArgs to ListFilter. cargo check passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add Export command match arm with plain-text and JSON output</name>
  <files>src/lib.rs</files>
  <action>
    In src/lib.rs, add:

    **build_filter_from_export private function** (similar to build_filter_from_list but takes ExportArgs):
    ```rust
    fn build_filter_from_export(args: &cli::ExportArgs) -> ticket::ListFilter {
        if args.claimed && args.unclaimed {
            eprintln!("Error: --claimed and --unclaimed are mutually exclusive");
            std::process::exit(1);
        }
        let claimed = if args.claimed {
            Some(true)
        } else if args.unclaimed {
            Some(false)
        } else {
            None
        };
        ticket::ListFilter {
            status: args.status.clone(),
            claimed,
            claimer: args.claimer.clone(),
            search: args.search.clone(),
        }
    }
    ```

    **Commands::Export match arm** — add to the match block in run():
    ```rust
    Commands::Export(args) => {
        let filter = build_filter_from_export(&args);
        let exports = ticket::tickets_to_export(&conn, &filter)?;
        if args.json {
            println!("{}", serde_json::to_string_pretty(&exports).expect("serialize"));
        } else {
            for e in &exports {
                println!("{}", ticket::format_export_text(e));
            }
        }
    }
    ```

    **Add serde_json import** at the top of lib.rs:
    ```rust
    use serde_json;
    ```
    (or use the fully-qualified path `serde_json::to_string_pretty` without an import — either works)

    The export command outputs nothing extra when there are no matches (empty loop/array). This is intentional — it matches typical Unix tool behavior (grep on no match outputs nothing, exits 0).

    Run `cargo build --release` to verify the full build including serde/serde_json linking.
  </action>
  <verify>cargo build --release --quiet 2>&amp;1 | grep -v warning; grep -q 'Commands::Export' src/lib.rs; grep -q 'to_string_pretty' src/lib.rs; ./target/release/rtik export --help 2>&amp;1 | grep -q 'json'</verify>
  <done>Release binary builds. Commands::Export match arm handles --json and plain-text paths. `rtik export --help` shows --json flag. `rtik dump --help` also works via alias.</done>
</task>

</tasks>

<verification>
Build and smoke-test:
  cargo build --release --quiet

  # Test aliases work
  RTIK_DB=/tmp/test-03-03.db ./target/release/rtik new -n "Test ticket" -d "desc"
  RTIK_DB=/tmp/test-03-03.db ./target/release/rtik ls
  RTIK_DB=/tmp/test-03-03.db ./target/release/rtik dump
  RTIK_DB=/tmp/test-03-03.db ./target/release/rtik dump --json

  # Clean up
  rm -f /tmp/test-03-03.db

Expected:
  - `new` creates ticket (prints "Created: #1 Test ticket")
  - `ls` lists it (table with status column)
  - `dump` prints "T-1 [todo] Test ticket" (plain text, no deps suffix)
  - `dump --json` prints JSON array with id, name, description, status, claimed_by, dependencies fields
</verification>

<success_criteria>
- Release binary compiles with zero errors
- `rtik new` alias works (creates ticket)
- `rtik ls` uses list_tickets_filtered (filter-compatible)
- `rtik ls --status todo` filters by status
- `rtik ls --search foo` filters by search term
- `rtik export` / `rtik dump` prints one line per ticket in T-{id} format
- `rtik export --json` prints valid JSON array
- `rtik ls --claimed --unclaimed` prints error and exits non-zero
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-filtering-export/03-03-SUMMARY.md`
</output>
