---
phase: 02-agent-coordination-dependencies
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/ticket.rs
  - src/cli.rs
  - src/lib.rs
autonomous: true
requirements: [STATE-04, COORD-01, COORD-02, COORD-03, TECH-03, TECH-04]

must_haves:
  truths:
    - "Agent can claim an unclaimed ticket; second claim attempt fails with owner info"
    - "Successful claim sets status to in-progress and records claimed_by and claimed_at"
    - "Agent can force-claim with --force, printing warning to stderr"
    - "Agent can release a claim; ticket resets to todo status with claim fields cleared"
    - "Agent can force-release with --force regardless of claim ownership"
    - "Marking a ticket done auto-releases the claim"
    - "rtik block #ID <reason> sets status to blocked and stores block_reason; missing reason exits 2"
    - "Status transitions are validated; invalid transition prints valid options and exits 1"
    - "Claiming a ticket with unmet deps warns but succeeds"
  artifacts:
    - path: "src/ticket.rs"
      provides: "claim_ticket, release_ticket, block_ticket, validate_transition functions"
      exports: ["claim_ticket", "release_ticket", "block_ticket", "validate_transition"]
    - path: "src/cli.rs"
      provides: "Claim, Release, Block subcommands"
      contains: "Claim"
    - path: "src/lib.rs"
      provides: "Dispatch arms for Claim, Release, Block; RTIK_AGENT resolution"
      contains: "RTIK_AGENT"
  key_links:
    - from: "src/lib.rs"
      to: "claim_ticket in ticket.rs"
      via: "Commands::Claim dispatch arm"
      pattern: "claim_ticket"
    - from: "src/ticket.rs claim_ticket"
      to: "SQLite UPDATE WHERE claimed_by IS NULL"
      via: "IMMEDIATE transaction + conn.changes()"
      pattern: "TransactionBehavior::Immediate"
    - from: "src/ticket.rs"
      to: "validate_transition"
      via: "called in update_ticket before writing new status"
      pattern: "validate_transition"
---

<objective>
Implement atomic claiming (COORD-01/02/03), claim release, the block command, and status state machine enforcement (STATE-04). This plan adds four new functions to ticket.rs, three new CLI subcommands, and wires everything through lib.rs dispatch. Agent identity is resolved via RTIK_AGENT environment variable.

Purpose: Multi-agent coordination requires atomic claiming to prevent two agents working the same ticket. Status transitions enforce coordination invariants (e.g., a done ticket cannot be directly re-set to todo — it must go through in-progress for rework visibility).
Output: Working claim, release, block commands plus validated status transitions on all update paths.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-coordination-dependencies/02-CONTEXT.md
@.planning/phases/02-agent-coordination-dependencies/02-RESEARCH.md
@.planning/phases/02-agent-coordination-dependencies/02-01-SUMMARY.md
@src/ticket.rs
@src/cli.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add claim, release, block, and validate_transition to ticket.rs</name>
  <files>src/ticket.rs</files>
  <action>
Add to src/ticket.rs (do not remove or restructure existing code):

**1. New AppError variants** (add to enum):
```rust
#[error("ticket #{0} already claimed by {1} since {2}")]
AlreadyClaimed(i64, String, String),
#[error("from {0}, valid transitions are: {}", .1.join(", "))]
InvalidTransition(String, Vec<String>),
#[error("block reason is required")]
BlockReasonRequired,
#[error("ticket #{0} not claimed by you ({1})")]
NotOwner(i64, String),
```

**2. validate_transition function** (pure, no DB):
```rust
pub fn validate_transition(from: &str, to: &str) -> Result<(), AppError> {
    let allowed: &[&str] = match from {
        "todo"        => &["in-progress", "blocked"],
        "in-progress" => &["done", "blocked", "todo"],
        "blocked"     => &["in-progress", "todo"],
        "done"        => &["in-progress"],
        _             => &[],
    };
    if allowed.contains(&to) {
        Ok(())
    } else {
        Err(AppError::InvalidTransition(
            from.to_string(),
            allowed.iter().map(|s| s.to_string()).collect(),
        ))
    }
}
```

Call `validate_transition` inside `update_ticket` when a new status is being set. Fetch the current status from DB first (query_row before the UPDATE), then call validate_transition(current_status, new_status). If it fails, return the error before building the SET clause. This adds one extra query per update-with-status-change — acceptable.

**3. claim_ticket function** (requires `&mut Connection` for IMMEDIATE tx):
```rust
pub fn claim_ticket(
    conn: &mut Connection,
    id: i64,
    agent: &str,
    force: bool,
) -> Result<(), AppError>
```
Implementation:
- Create IMMEDIATE transaction: `conn.transaction_with_behavior(TransactionBehavior::Immediate)?`
- Add import: `use rusqlite::TransactionBehavior;`
- If `force`: query current claimed_by, print warning to stderr if Some, then UPDATE unconditionally setting claimed_by, claimed_at, status='in-progress', updated_at
- If not force: `UPDATE tickets SET claimed_by=?1, claimed_at=?2, status='in-progress', updated_at=?2 WHERE id=?3 AND claimed_by IS NULL`; check `tx.changes() == 0`; if zero, query row to distinguish NotFound vs AlreadyClaimed
- Before updating: check if ticket has any unmet deps (deps where depending ticket's status != 'done'). Count them with a query on ticket_deps joined to tickets. If count > 0, eprintln to stderr: `Warning: {count} dependencies not done`
- `tx.commit()?`

**4. release_ticket function** (requires `&mut Connection`):
```rust
pub fn release_ticket(
    conn: &mut Connection,
    id: i64,
    agent: &str,
    force: bool,
) -> Result<(), AppError>
```
Implementation:
- IMMEDIATE transaction
- If not force: fetch claimed_by; if None, return NotFound-like error (ticket not claimed — use a descriptive message; add `#[error("ticket #{0} is not currently claimed")] NotClaimed(i64)` variant); if claimed_by != agent, return NotOwner error; warn to stderr if force is true and claimed_by != agent
- If force: fetch claimed_by for warning, eprintln "Warning: overriding claim by {owner}" if Some and owner != agent
- UPDATE: `SET claimed_by=NULL, claimed_at=NULL, status='todo', updated_at=? WHERE id=?`
- `tx.commit()?`

**5. block_ticket function**:
```rust
pub fn block_ticket(
    conn: &Connection,
    id: i64,
    reason: &str,
) -> Result<String, AppError>
```
Implementation (does NOT need mutable connection — uses regular execute, no IMMEDIATE tx needed here):
- Fetch current ticket to get current status and name (returns NotFound if missing)
- Validate transition from current status to "blocked" using validate_transition
- Execute: `UPDATE tickets SET status='blocked', block_reason=?1, updated_at=?2 WHERE id=?3`
- Return ticket name for confirmation output

Note on done→release: In update_ticket, when new status is 'done', also clear claimed_by and claimed_at:
Add to the SET clause when status becomes 'done': `claimed_by=NULL, claimed_at=NULL`.
Do this inside the existing update_ticket dynamic params logic — add a special case: if normalized_status.as_deref() == Some("done"), push "claimed_by = :claimnil" with NULL value and "claimed_at = :claimnil_at" with NULL. Use separate `:claimnil` and `:claimnil_at` param names bound to &rusqlite::types::Null (use `rusqlite::types::Null` for NULL binding).
  </action>
  <verify>cargo build 2>&1</verify>
  <done>
    - `cargo build` succeeds with no warnings about unused imports
    - validate_transition, claim_ticket, release_ticket, block_ticket all compile
    - update_ticket calls validate_transition when status is provided
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Claim/Release/Block CLI subcommands and dispatch in cli.rs + lib.rs</name>
  <files>src/cli.rs, src/lib.rs</files>
  <action>
**In src/cli.rs — add three new subcommands:**

Add to the Commands enum:
```rust
/// Claim a ticket for this agent
Claim(ClaimArgs),
/// Release a claimed ticket
Release(ReleaseArgs),
/// Block a ticket with a reason
Block(BlockArgs),
```

Add corresponding Args structs:
```rust
#[derive(Args)]
pub struct ClaimArgs {
    pub id: i64,
    #[arg(long, help = "Override another agent's claim")]
    pub force: bool,
}

#[derive(Args)]
pub struct ReleaseArgs {
    pub id: i64,
    #[arg(long, help = "Release regardless of ownership")]
    pub force: bool,
}

#[derive(Args)]
pub struct BlockArgs {
    pub id: i64,
    pub reason: String,
}
```

Update `parse_status` to also include the new status set if anything references the old list. No change needed if it was already updated in Plan 01.

**In src/lib.rs — wire dispatch and agent resolution:**

Change `run` signature to accept `&mut Connection` instead of `Connection` (the caller in main.rs must pass `&mut conn`). Update main.rs accordingly if needed — check how run is called.

Actually: keep `conn: Connection` parameter but convert to mut inside run: `let mut conn = conn;`. This avoids changing the public signature unnecessarily.

Add agent resolution helper (private function or inline in run):
```rust
fn resolve_agent() -> Result<String, AppError> {
    std::env::var("RTIK_AGENT").map_err(|_| {
        // Use a string error — add a new AppError variant or use a plain eprintln + exit
        // Simplest: add variant
        AppError::AgentNotSet
    })
}
```
Add to AppError: `#[error("RTIK_AGENT not set — set it to identify this agent")]  AgentNotSet`

Add dispatch arms in the match:
```rust
Commands::Claim(args) => {
    let agent = resolve_agent()?;
    ticket::claim_ticket(&mut conn, args.id, &agent, args.force)?;
    println!("Claimed #{}", args.id);
}
Commands::Release(args) => {
    let agent = resolve_agent()?;
    ticket::release_ticket(&mut conn, args.id, &agent, args.force)?;
    println!("Released #{}", args.id);
}
Commands::Block(args) => {
    let name = ticket::block_ticket(&conn, args.id, &args.reason)?;
    println!("Blocked: #{} {}", args.id, name);
}
```

After adding the dispatch, run a smoke test sequence:
```bash
export RTIK_AGENT=agent-1
RTIK_DB=/tmp/smoke2.db cargo run -- create --name "Test claim"
RTIK_DB=/tmp/smoke2.db cargo run -- claim 1
RTIK_DB=/tmp/smoke2.db cargo run -- get 1       # should show in-progress, claimed_by=agent-1
RTIK_DB=/tmp/smoke2.db cargo run -- release 1
RTIK_DB=/tmp/smoke2.db cargo run -- get 1       # should show todo, no claim
RTIK_DB=/tmp/smoke2.db cargo run -- block 1 "waiting on upstream"
RTIK_DB=/tmp/smoke2.db cargo run -- get 1       # should show blocked
```
  </action>
  <verify>cargo build 2>&1 && cargo test 2>&1</verify>
  <done>
    - `cargo build` succeeds
    - `cargo test` passes all existing tests
    - Smoke test: claim sets status to in-progress, release resets to todo, block sets status to blocked
    - `RTIK_AGENT` unset → `rtik claim 1` prints error and exits 1
    - `rtik block 1` (missing reason) exits 2 (Clap usage error — reason is a required positional arg)
  </done>
</task>

</tasks>

<verification>
Full flow test (with RTIK_AGENT set):
1. Create two tickets
2. Claim ticket 1 as agent-1 → exits 0, get shows claimed_by=agent-1, status=in-progress
3. Claim ticket 1 as agent-2 (different RTIK_AGENT) → exits 1 with "claimed by agent-1 since ..."
4. Force-claim ticket 1 as agent-2 → exits 0, stderr shows warning, get shows claimed_by=agent-2
5. Release ticket 1 as agent-2 → exits 0, get shows todo, no claim fields
6. Update ticket 2 to done → auto-clears claim (if it had one)
7. Update ticket 2 from done to todo → exits 1 with "valid transitions are: in-progress"
8. Block ticket 2 with reason → exits 0, get shows blocked
9. `rtik block 2` (no reason) → exits 2 (usage error)
Run `cargo test` — all tests pass.
</verification>

<success_criteria>
- Atomic claiming works: two concurrent attempts, exactly one succeeds (verified by conn.changes() logic)
- Status state machine enforced: invalid transitions rejected with valid options listed
- claim_ticket uses IMMEDIATE transaction (TransactionBehavior::Immediate in source)
- Marking done auto-releases claim (claimed_by=NULL in DB)
- RTIK_AGENT env var required; missing → clear error
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-coordination-dependencies/02-02-SUMMARY.md`
</output>
