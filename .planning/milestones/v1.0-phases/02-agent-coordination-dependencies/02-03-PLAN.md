---
phase: 02-agent-coordination-dependencies
plan: 03
type: execute
wave: 3
depends_on: [02-02]
files_modified:
  - src/ticket.rs
  - src/cli.rs
  - src/lib.rs
autonomous: true
requirements: [COORD-04, COORD-05, COORD-06]

must_haves:
  truths:
    - "User can add a dependency between two tickets; system rejects self-dependencies"
    - "System detects and rejects circular dependencies with the cycle path in the error"
    - "User can remove a dependency between two tickets"
    - "rtik deps #ID shows forward and reverse dependencies for a ticket"
    - "rtik get #ID shows Depends on and Required by lists"
    - "rtik list shows dep count for tickets that have dependencies"
  artifacts:
    - path: "src/ticket.rs"
      provides: "add_dep, remove_dep, list_deps, would_create_cycle functions"
      exports: ["add_dep", "remove_dep", "list_deps", "would_create_cycle"]
    - path: "src/cli.rs"
      provides: "Dep subcommand with add/remove sub-subcommands; top-level Deps command"
      contains: "Deps"
    - path: "src/lib.rs"
      provides: "Dispatch for Dep::Add, Dep::Remove, and top-level Commands::Deps"
      contains: "Commands::Deps"
  key_links:
    - from: "src/ticket.rs add_dep"
      to: "would_create_cycle"
      via: "called before INSERT INTO ticket_deps"
      pattern: "would_create_cycle"
    - from: "src/ticket.rs would_create_cycle"
      to: "ticket_deps table"
      via: "SELECT ticket_id, depends_on FROM ticket_deps"
      pattern: "ticket_deps"
    - from: "src/lib.rs Commands::Deps"
      to: "list_deps in ticket.rs"
      via: "top-level Deps dispatch arm"
      pattern: "Commands::Deps"
    - from: "src/lib.rs"
      to: "list_tickets in ticket.rs"
      via: "List command augmented to show dep count per ticket"
      pattern: "dep_count"
---

<objective>
Implement dependency management: add/remove dependencies between tickets with cycle detection (COORD-04/05/06), a `deps` command for tree view, updated `get` output with forward and reverse deps, and dep count display in `list`. Cycle detection uses in-process DFS over the adjacency list loaded from DB — no new crate dependencies.

Purpose: Agents need to express and query work ordering. Circular dependency detection prevents deadlocks where agent A waits for B while B waits for A.
Output: Working dep add/remove commands, cycle detection with path reporting, and dep info in get/list/deps views.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-coordination-dependencies/02-CONTEXT.md
@.planning/phases/02-agent-coordination-dependencies/02-RESEARCH.md
@.planning/phases/02-agent-coordination-dependencies/02-02-SUMMARY.md
@src/ticket.rs
@src/cli.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependency functions to ticket.rs (add_dep, remove_dep, list_deps, cycle detection)</name>
  <files>src/ticket.rs</files>
  <action>
Add to src/ticket.rs:

**New AppError variants:**
```rust
#[error("cycle detected: {0}")]
CyclicDependency(String),  // message like "#3 → #7 → #3"
#[error("dependency from #{0} to #{1} not found")]
DepNotFound(i64, i64),
```

**would_create_cycle function (in-process DFS):**
```rust
use std::collections::{HashMap, HashSet};

pub fn would_create_cycle(
    conn: &Connection,
    ticket_id: i64,
    new_dep: i64,
) -> Result<Option<Vec<i64>>, AppError> {
    let mut adj: HashMap<i64, Vec<i64>> = HashMap::new();
    let mut stmt = conn.prepare(
        "SELECT ticket_id, depends_on FROM ticket_deps"
    )?;
    let rows = stmt.query_map([], |r| Ok((r.get::<_, i64>(0)?, r.get::<_, i64>(1)?)))?;
    for row in rows {
        let (from, to) = row?;
        adj.entry(from).or_default().push(to);
    }
    // Hypothetically add the proposed edge
    adj.entry(ticket_id).or_default().push(new_dep);

    // DFS from new_dep: if it can reach ticket_id, there's a cycle
    let mut visited: HashSet<i64> = HashSet::new();
    let mut path: Vec<i64> = Vec::new();
    if dfs_finds_target(&adj, new_dep, ticket_id, &mut visited, &mut path) {
        path.insert(0, ticket_id);
        return Ok(Some(path));
    }
    Ok(None)
}

fn dfs_finds_target(
    adj: &HashMap<i64, Vec<i64>>,
    current: i64,
    target: i64,
    visited: &mut HashSet<i64>,
    path: &mut Vec<i64>,
) -> bool {
    if current == target { return true; }
    if !visited.insert(current) { return false; }
    path.push(current);
    if let Some(neighbors) = adj.get(&current) {
        for &next in neighbors {
            if dfs_finds_target(adj, next, target, visited, path) {
                return true;
            }
        }
    }
    path.pop();
    false
}
```

**add_dep function:**
```rust
pub fn add_dep(conn: &Connection, ticket_id: i64, depends_on: i64) -> Result<(), AppError>
```
- Verify both tickets exist (get_ticket for each — returns NotFound if missing)
- Self-dependency is caught by the DB CHECK (ticket_id != depends_on) — let it propagate as Db error, or pre-check with: if ticket_id == depends_on { return Err(AppError::CyclicDependency(format!("#{} → #{}", ticket_id, depends_on))) }
- Call would_create_cycle(conn, ticket_id, depends_on)?; if Some(path), format cycle string and return CyclicDependency error: `path.iter().map(|id| format!("#{}", id)).collect::<Vec<_>>().join(" → ")`
- INSERT INTO ticket_deps (ticket_id, depends_on) VALUES (?1, ?2) — if already exists, rusqlite returns UNIQUE constraint error; map it to a Db error (acceptable — user can see it)

**remove_dep function:**
```rust
pub fn remove_dep(conn: &Connection, ticket_id: i64, depends_on: i64) -> Result<(), AppError>
```
- `DELETE FROM ticket_deps WHERE ticket_id=?1 AND depends_on=?2`
- Check `conn.changes() == 0` → DepNotFound

**list_deps function:**
Returns forward deps (what this ticket depends on) and reverse deps (what depends on this ticket):
```rust
pub struct DepInfo {
    pub forward: Vec<i64>,   // ticket_id depends on these
    pub reverse: Vec<i64>,   // these depend on ticket_id
}

pub fn list_deps(conn: &Connection, ticket_id: i64) -> Result<DepInfo, AppError>
```
- Query forward: `SELECT depends_on FROM ticket_deps WHERE ticket_id=?1 ORDER BY depends_on`
- Query reverse: `SELECT ticket_id FROM ticket_deps WHERE depends_on=?1 ORDER BY ticket_id`
- Return DepInfo { forward, reverse }
  </action>
  <verify>cargo build 2>&1</verify>
  <done>
    - `cargo build` succeeds
    - All four functions (would_create_cycle, add_dep, remove_dep, list_deps) compile
    - DepInfo struct exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Dep subcommand, update get/list display, wire dispatch in cli.rs + lib.rs</name>
  <files>src/cli.rs, src/lib.rs</files>
  <action>
**In src/cli.rs — add Dep subcommand and top-level Deps command:**

Add to Commands enum:
```rust
/// Manage ticket dependencies (add/remove)
Dep(DepArgs),
/// Show dependency tree for a ticket (rtik deps #ID)
Deps(DepsArgs),
```

```rust
#[derive(Args)]
pub struct DepArgs {
    #[command(subcommand)]
    pub action: DepAction,
}

#[derive(Subcommand)]
pub enum DepAction {
    /// Add a dependency: ticket_id depends on dep_id
    Add { ticket_id: i64, dep_id: i64 },
    /// Remove a dependency
    Remove { ticket_id: i64, dep_id: i64 },
}

#[derive(Args)]
pub struct DepsArgs {
    pub id: i64,
}
```

`Deps` is a dedicated top-level command per CONTEXT.md ("Dedicated `rtik deps #ID` command for dependency tree view"). `Dep` handles only add/remove mutations.

**In src/lib.rs — wire dispatch:**

Add dispatch arms:
```rust
Commands::Dep(args) => {
    match args.action {
        cli::DepAction::Add { ticket_id, dep_id } => {
            ticket::add_dep(&conn, ticket_id, dep_id)?;
            println!("Added: #{} depends on #{}", ticket_id, dep_id);
        }
        cli::DepAction::Remove { ticket_id, dep_id } => {
            ticket::remove_dep(&conn, ticket_id, dep_id)?;
            println!("Removed: #{} no longer depends on #{}", ticket_id, dep_id);
        }
    }
}
Commands::Deps(args) => {
    let deps = ticket::list_deps(&conn, args.id)?;
    if deps.forward.is_empty() && deps.reverse.is_empty() {
        println!("#{} has no dependencies.", args.id);
    } else {
        if !deps.forward.is_empty() {
            let fwd = deps.forward.iter().map(|i| format!("#{}", i)).collect::<Vec<_>>().join(", ");
            println!("Depends on: {}", fwd);
        }
        if !deps.reverse.is_empty() {
            let rev = deps.reverse.iter().map(|i| format!("#{}", i)).collect::<Vec<_>>().join(", ");
            println!("Required by: {}", rev);
        }
    }
}
```

**Update Commands::Get dispatch** to show dep info after the existing output:
After printing "Created: | Updated:" line, call `list_deps(&conn, id)?` and if either forward or reverse is non-empty, print:
```
Depends on: #3, #7
Required by: #9
```
(only print lines that have content)

**Update Commands::List dispatch** to show dep count:
After loading tickets, also query for dep counts per ticket. Use a single query:
`SELECT ticket_id, COUNT(*) FROM ticket_deps GROUP BY ticket_id`
Build a HashMap<i64, i64> of ticket_id → dep_count. In each row display, if dep_count > 0, append ` [N deps]` after the name (before the name column ends). Adjust truncation so total still fits — truncate name to 35 chars if dep suffix is present.

Run smoke test:
```bash
RTIK_DB=/tmp/deps.db cargo run -- create --name "Alpha"
RTIK_DB=/tmp/deps.db cargo run -- create --name "Beta"
RTIK_DB=/tmp/deps.db cargo run -- create --name "Gamma"
RTIK_DB=/tmp/deps.db cargo run -- dep add 2 1   # Beta depends on Alpha
RTIK_DB=/tmp/deps.db cargo run -- dep add 3 2   # Gamma depends on Beta
RTIK_DB=/tmp/deps.db cargo run -- dep add 1 3   # Alpha depends on Gamma → CYCLE
RTIK_DB=/tmp/deps.db cargo run -- deps 2        # Depends on: #1 / Required by: #3
RTIK_DB=/tmp/deps.db cargo run -- list          # Shows [1 dep] for Beta and Gamma
RTIK_DB=/tmp/deps.db cargo run -- get 2         # Shows Depends on: #1 / Required by: #3
```
  </action>
  <verify>cargo build 2>&1 && cargo test 2>&1</verify>
  <done>
    - `cargo build` succeeds
    - `cargo test` passes all existing tests
    - Smoke test: dep add succeeds for valid deps, fails with cycle error showing path for circular dep
    - `deps #ID` outputs correct forward and reverse dep lists
    - `list` shows `[N deps]` for tickets with dependencies
    - `get` shows "Depends on:" and "Required by:" sections
  </done>
</task>

</tasks>

<verification>
Full dependency flow:
1. Create 3 tickets (A, B, C)
2. `dep add 2 1` (B depends on A) → exits 0
3. `dep add 3 2` (C depends on B) → exits 0
4. `dep add 1 3` (A depends on C — creates cycle A→C→B→A) → exits 1 with cycle path in error
5. `deps 2` → shows "Depends on: #1" and "Required by: #3"
6. `list` → B and C show `[1 dep]`
7. `get 2` → shows dep section
8. `dep remove 2 1` → exits 0
9. `deps 2` → no deps
10. Delete ticket A → B's dep on A auto-removed via CASCADE (verify with dep show)
Run `cargo test` — all tests pass.
</verification>

<success_criteria>
- Circular dependency detection works and reports cycle path: `Error: cycle detected: #1 → #3 → #2 → #1`
- ON DELETE CASCADE removes dep rows when a ticket is deleted
- add_dep, remove_dep, list_deps all function correctly end-to-end
- get and list output shows dependency information
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-coordination-dependencies/02-03-SUMMARY.md`
</output>
