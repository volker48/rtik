---
phase: 02-agent-coordination-dependencies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db.rs
  - src/cli.rs
  - tests/integration.rs
autonomous: true
requirements: [STATE-04, COORD-01]

must_haves:
  truths:
    - "Database schema supports claimed_by, claimed_at, block_reason columns on tickets"
    - "ticket_deps table exists with FK cascade and self-reference prevention"
    - "Status values in DB and CLI accept in-progress (not wip)"
    - "All existing Phase 1 tests pass with the renamed status"
  artifacts:
    - path: "src/db.rs"
      provides: "Migration M2 with 12-step table rebuild and new columns + ticket_deps"
      contains: "in-progress"
    - path: "src/cli.rs"
      provides: "parse_status updated to accept in-progress"
      contains: "in-progress"
    - path: "tests/integration.rs"
      provides: "Updated tests using in-progress instead of wip"
  key_links:
    - from: "src/db.rs"
      to: "rusqlite_migration MIGRATIONS slice"
      via: "M2 appended to static MIGRATIONS"
      pattern: "M::up"
    - from: "src/cli.rs"
      to: "parse_status"
      via: "value_parser on UpdateArgs --status"
      pattern: "in-progress"
---

<objective>
Add migration M2 to evolve the schema: rename `wip` to `in-progress` (requires 12-step SQLite table rebuild since CHECK constraints cannot be altered), add `claimed_by`, `claimed_at`, and `block_reason` columns to tickets, and create the `ticket_deps` table. Update `parse_status` in cli.rs and fix all Phase 1 integration tests that reference `wip`.

Purpose: All Phase 2 features (claiming, blocking, dependencies) require schema support. The `wip`→`in-progress` rename is a required prerequisite — CONTEXT.md locks in `in-progress` as the valid status value, but Phase 1 shipped with `wip`. This migration resolves the discrepancy cleanly before any new code builds on top.
Output: Updated db.rs with M2 migration, updated cli.rs parse_status, updated integration tests — all passing.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-operations/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-operations/01-03-SUMMARY.md
@src/db.rs
@src/cli.rs
@tests/integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add M2 migration to db.rs (schema evolution)</name>
  <files>src/db.rs</files>
  <action>
Append a second migration M2 to the static MIGRATIONS slice in src/db.rs.

M2 must do three things in one M::up() call (multi-statement string):

**Step 1 — Rename wip→in-progress via 12-step table rebuild:**
SQLite cannot ALTER a CHECK constraint, so rebuild the table:
```
CREATE TABLE tickets_new (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    name        TEXT NOT NULL,
    description TEXT NOT NULL DEFAULT '',
    status      TEXT NOT NULL DEFAULT 'todo'
                CHECK(status IN ('todo','in-progress','blocked','done')),
    claimed_by  TEXT,
    claimed_at  TEXT,
    block_reason TEXT,
    created_at  TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ','now')),
    updated_at  TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ','now'))
);
INSERT INTO tickets_new
    SELECT id, name, description,
           CASE status WHEN 'wip' THEN 'in-progress' ELSE status END,
           NULL, NULL, NULL,
           created_at, updated_at
    FROM tickets;
DROP TABLE tickets;
ALTER TABLE tickets_new RENAME TO tickets;
```

**Step 2 — Create ticket_deps table:**
```
CREATE TABLE ticket_deps (
    ticket_id  INTEGER NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
    depends_on INTEGER NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
    PRIMARY KEY (ticket_id, depends_on),
    CHECK (ticket_id != depends_on)
);
```

Join all statements into a single M::up("...") string separated by semicolons. Append as the second element of the MIGRATIONS slice after the existing M1.

No new crate dependencies — rusqlite_migration already handles multi-statement migrations.

Note: `busy_timeout` should be set via `conn.busy_timeout(Duration::from_secs(5))` in open_connection after pragmas but before migrations — add this import and call. This ensures write contention from concurrent agents fails gracefully rather than immediately. Import `std::time::Duration`.

Note: All write transactions in Phase 2 use `TransactionBehavior::Immediate`. The migration itself runs in the migration library's own transaction — that is fine. The IMMEDIATE mode applies to claim/release functions added in Plan 02, not here.
  </action>
  <verify>cargo build 2>&1; cargo test 2>&1</verify>
  <done>
    - `cargo build` succeeds with no errors
    - `cargo test` passes all existing 13 integration tests (they may fail temporarily if still using 'wip' — fix in Task 2)
    - `.rtik.db` (if present) can be migrated: `RTIK_DB=/tmp/test.db cargo run -- list` succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Update parse_status and fix Phase 1 tests for in-progress</name>
  <files>src/cli.rs, tests/integration.rs</files>
  <action>
**In src/cli.rs — update parse_status:**

Replace the current accepted values `"todo" | "wip" | "blocked" | "done"` with `"todo" | "in-progress" | "blocked" | "done"`. Update the error message to list the new valid values.

Also update the `InvalidStatus` variant message in ticket.rs AppError if it still references `wip` — check and update if needed.

**In tests/integration.rs — update all wip references:**

Search for every assertion that checks `status == "wip"` or similar, and replace `"wip"` with `"in-progress"`. Also update any test that sets status to `"wip"` via update_ticket or similar.

After the rename, if any test creates a ticket and then updates it to `wip`, that update will now fail at the DB CHECK constraint — update those tests to use `in-progress`.

Run `cargo test` to verify all 13 existing tests pass. Then run a quick smoke test:
```
cargo build
RTIK_DB=/tmp/smoke.db cargo run -- create --name "Test ticket"
RTIK_DB=/tmp/smoke.db cargo run -- update 1 --status in-progress
RTIK_DB=/tmp/smoke.db cargo run -- get 1
```
Confirm `get` output shows `[in-progress]`.
  </action>
  <verify>cargo test 2>&1 | tail -5</verify>
  <done>
    - `cargo test` shows all tests passed (no failures)
    - `parse_status("in-progress")` returns Ok("in-progress")
    - `parse_status("wip")` returns Err (wip no longer valid)
    - Smoke test: updating ticket status to in-progress persists and displays correctly
  </done>
</task>

</tasks>

<verification>
Run full test suite: `cargo test`
All 13 Phase 1 integration tests pass.
Schema has claimed_by, claimed_at, block_reason columns: `RTIK_DB=/tmp/v.db cargo run -- create --name x && sqlite3 /tmp/v.db ".schema tickets"`
ticket_deps table exists: `sqlite3 /tmp/v.db ".schema ticket_deps"`
Status CHECK allows in-progress: `RTIK_DB=/tmp/v.db cargo run -- update 1 --status in-progress` exits 0.
Status CHECK rejects wip: `RTIK_DB=/tmp/v.db cargo run -- update 1 --status wip` exits non-zero.
</verification>

<success_criteria>
- M2 migration runs cleanly on a fresh DB and on a DB with existing wip-status rows
- All Phase 1 integration tests pass
- Schema contains: claimed_by TEXT, claimed_at TEXT, block_reason TEXT on tickets; ticket_deps table with cascade FK
- in-progress is the valid status (wip rejected at CLI and DB levels)
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-coordination-dependencies/02-01-SUMMARY.md`
</output>
