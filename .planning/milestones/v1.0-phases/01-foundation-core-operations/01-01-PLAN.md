---
phase: 01-foundation-core-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/lib.rs
  - src/cli.rs
  - src/db.rs
  - src/ticket.rs
autonomous: true
requirements:
  - TECH-01
  - TECH-02
  - TECH-05
  - TECH-06
  - CLI-05
  - CLI-06
  - STATE-05

must_haves:
  truths:
    - "cargo build --release succeeds and produces a single binary at target/release/rtik"
    - "Running rtik with no arguments exits with code 2 and prints usage to stderr"
    - "Database opens in WAL mode with synchronous=NORMAL after first connection"
    - "Schema migration runs on first open, creating the tickets table with correct columns"
    - "DB path resolves: RTIK_DB env var > walk parents for .rtik.db > cwd/.rtik.db"
  artifacts:
    - path: "Cargo.toml"
      provides: "Package definition with all required dependencies"
      contains: "bundled"
    - path: "src/main.rs"
      provides: "CLI entry point with sigpipe reset and exit code handling"
      contains: "sigpipe::reset"
    - path: "src/db.rs"
      provides: "DB connection, WAL setup, migrations, path resolution"
      exports: ["open_connection", "resolve_db_path"]
    - path: "src/ticket.rs"
      provides: "Ticket struct and domain error type (stub, wired to DB)"
      contains: "pub struct Ticket"
    - path: "src/cli.rs"
      provides: "Clap top-level Cli struct and Commands enum (stub subcommands)"
      contains: "pub struct Cli"
    - path: "src/lib.rs"
      provides: "Re-exports db, ticket, cli modules"
  key_links:
    - from: "src/main.rs"
      to: "src/db.rs"
      via: "resolve_db_path + open_connection call"
      pattern: "resolve_db_path|open_connection"
    - from: "src/db.rs"
      to: "rusqlite_migration"
      via: "Migrations::from_slice(MIGRATIONS).to_latest"
      pattern: "to_latest"
---

<objective>
Bootstrap the Rust project with all dependencies and implement the database layer.

Purpose: Every subsequent plan depends on this foundation — the binary must compile and the DB layer
must be correct before any CRUD can be written.
Output: Compiling Cargo workspace with correct deps; db.rs implementing WAL setup, schema migration,
and directory-walking path resolution; stub module structure ready for Plan 02 to fill.
</objective>

<execution_context>
@/Users/marcusmccurdy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcusmccurdy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-operations/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Cargo project and dependencies</name>
  <files>
    Cargo.toml
    src/lib.rs
    src/ticket.rs
  </files>
  <action>
Run `cargo init --name rtik` in the project root to create the standard Rust project structure.

Then replace the generated Cargo.toml with:

```toml
[package]
name = "rtik"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "rtik"
path = "src/main.rs"

[dependencies]
clap = { version = "4.5", features = ["derive"] }
rusqlite = { version = "0.38", features = ["bundled"] }
rusqlite_migration = "2.4"
sigpipe = "0.1"
thiserror = "2"
```

The `features = ["bundled"]` is mandatory — it statically links libsqlite3 into the binary,
satisfying TECH-05. Without it the binary would require libsqlite3 installed on the target system.

Create `src/lib.rs` that declares and re-exports the three modules:

```rust
pub mod cli;
pub mod db;
pub mod ticket;
```

Create `src/ticket.rs` as a stub with the Ticket struct and domain error type:

```rust
use thiserror::Error;

#[derive(Debug)]
pub struct Ticket {
    pub id: i64,
    pub name: String,
    pub description: String,
    pub status: String,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Debug, Error)]
pub enum AppError {
    #[error("ticket #{0} not found")]
    NotFound(i64),
    #[error("no fields provided — use --name, --desc, or --status")]
    NoUpdateFields,
    #[error("invalid status '{0}': must be one of todo, wip, blocked, done")]
    InvalidStatus(String),
    #[error(transparent)]
    Db(#[from] rusqlite::Error),
}
```

Run `cargo check` to confirm the project compiles with all dependencies resolved.
  </action>
  <verify>
    `cargo check` exits with code 0 and no errors.
    `cargo tree | grep rusqlite` shows rusqlite with the bundled feature.
  </verify>
  <done>
    Cargo.toml exists with correct deps including `features = ["bundled"]` on rusqlite.
    src/lib.rs declares cli, db, ticket modules.
    src/ticket.rs has Ticket struct and AppError enum.
    `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DB layer (connection, WAL, migrations, path resolution)</name>
  <files>
    src/db.rs
    src/main.rs
    src/cli.rs
  </files>
  <action>
Create `src/db.rs` implementing the full database layer:

```rust
use rusqlite::Connection;
use rusqlite_migration::{Migrations, M};
use std::path::PathBuf;

use crate::ticket::AppError;

static MIGRATIONS: &[M<'static>] = &[
    M::up(
        "CREATE TABLE tickets (
            id          INTEGER PRIMARY KEY AUTOINCREMENT,
            name        TEXT NOT NULL,
            description TEXT NOT NULL DEFAULT '',
            status      TEXT NOT NULL DEFAULT 'todo'
                        CHECK(status IN ('todo','wip','blocked','done')),
            created_at  TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ','now')),
            updated_at  TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ','now'))
        );"
    ),
];

pub fn resolve_db_path() -> PathBuf {
    if let Ok(path) = std::env::var("RTIK_DB") {
        return PathBuf::from(path);
    }
    let mut dir = std::env::current_dir().expect("cannot read cwd");
    loop {
        let candidate = dir.join(".rtik.db");
        if candidate.exists() {
            return candidate;
        }
        if !dir.pop() {
            break;
        }
    }
    std::env::current_dir()
        .expect("cannot read cwd")
        .join(".rtik.db")
}

pub fn open_connection(path: &std::path::Path) -> Result<Connection, AppError> {
    let mut conn = Connection::open(path)?;
    conn.pragma_update(None, "journal_mode", "WAL")?;
    conn.pragma_update(None, "synchronous", "NORMAL")?;
    conn.pragma_update(None, "foreign_keys", "ON")?;
    Migrations::from_slice(MIGRATIONS)
        .to_latest(&mut conn)
        .expect("migration failed");
    Ok(conn)
}
```

Key points:
- `resolve_db_path`: checks RTIK_DB env var first, then walks parent dirs looking for `.rtik.db`,
  falls back to creating in cwd. This is git-like behavior per user decision.
- `open_connection`: sets WAL mode and synchronous=NORMAL IMMEDIATELY after open (Pitfall 4 in
  RESEARCH.md — must happen before any other operation). Then runs migrations.
- The schema uses a CHECK constraint on status for data integrity, and `strftime` for UTC timestamps
  (Pitfall 2 — avoids SQLite's non-ISO CURRENT_TIMESTAMP format).

Create `src/cli.rs` as a working stub with all subcommands declared (no implementation yet — just
the Clap structs that make the binary parse correctly):

```rust
use clap::{Args, Parser, Subcommand};

#[derive(Parser)]
#[command(name = "rtik", about = "Ticket tracker for agents", version)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Create a new ticket
    Create(CreateArgs),
    /// Show ticket details
    Get { id: i64 },
    /// Update ticket fields (at least one required)
    Update(UpdateArgs),
    /// Delete a ticket
    Delete { id: i64 },
    /// List all tickets
    List(ListArgs),
}

#[derive(Args)]
pub struct CreateArgs {
    #[arg(short = 'n', long, help = "Ticket name")]
    pub name: String,
    #[arg(short = 'd', long, help = "Ticket description")]
    pub desc: Option<String>,
}

#[derive(Args)]
pub struct UpdateArgs {
    pub id: i64,
    #[arg(short = 'n', long)]
    pub name: Option<String>,
    #[arg(short = 'd', long)]
    pub desc: Option<String>,
    #[arg(long, value_parser = parse_status)]
    pub status: Option<String>,
}

#[derive(Args)]
pub struct ListArgs {
    /// Show created/updated timestamps
    #[arg(long)]
    pub timestamps: bool,
}

fn parse_status(raw: &str) -> Result<String, String> {
    let normalized = raw.to_lowercase();
    match normalized.as_str() {
        "todo" | "wip" | "blocked" | "done" => Ok(normalized),
        _ => Err(format!(
            "invalid status '{}': must be one of todo, wip, blocked, done",
            raw
        )),
    }
}
```

Create `src/main.rs` with the complete entry point structure:

```rust
use clap::Parser;

fn main() {
    sigpipe::reset(); // CLI-06: must be first — resets SIGPIPE before any I/O

    let cli = rtik::cli::Cli::parse(); // exits with code 2 on usage error (CLI-05)
    let db_path = rtik::db::resolve_db_path();
    let conn = match rtik::db::open_connection(&db_path) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("Error: cannot open database: {e}");
            std::process::exit(1);
        }
    };

    if let Err(e) = rtik::run(cli, conn) {
        eprintln!("Error: {e}");
        std::process::exit(1);
    }
}
```

Add a stub `pub fn run` to `src/lib.rs` that returns Ok(()) so the binary compiles:

```rust
pub mod cli;
pub mod db;
pub mod ticket;

use rusqlite::Connection;
use ticket::AppError;

pub fn run(cli: cli::Cli, _conn: Connection) -> Result<(), AppError> {
    use cli::Commands;
    match cli.command {
        Commands::Create(_) => todo!("create"),
        Commands::Get { .. } => todo!("get"),
        Commands::Update(_) => todo!("update"),
        Commands::Delete { .. } => todo!("delete"),
        Commands::List(_) => todo!("list"),
    }
}
```

Run `cargo build` to confirm the project compiles end-to-end (the `todo!` macros are fine — they
panic at runtime, not compile time).
  </action>
  <verify>
    `cargo build` exits with code 0 and produces `target/debug/rtik`.
    `./target/debug/rtik --help` prints usage and exits with code 0.
    `./target/debug/rtik` with no args exits with code 2 (Clap usage error).
    `./target/debug/rtik create --name "test"` panics with "create" (confirms wiring reaches run()).
  </verify>
  <done>
    src/db.rs implements resolve_db_path and open_connection with WAL + migrations.
    src/cli.rs has all Clap structs for all 5 subcommands.
    src/main.rs calls sigpipe::reset() as first line, routes errors to stderr, exits with 1.
    `cargo build` succeeds.
    Binary responds to --help and exits 2 with no subcommand.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo build --release` succeeds — produces target/release/rtik
2. `target/release/rtik --help` exits 0 with usage info
3. `target/release/rtik` exits 2 (no subcommand = usage error)
4. `cargo tree | grep -E "rusqlite|clap|sigpipe|rusqlite_migration|thiserror"` shows all 5 dependencies
5. Inspect src/db.rs to confirm WAL pragma and migration setup
</verification>

<success_criteria>
- Cargo.toml has all 5 dependencies with correct versions and bundled feature
- Binary compiles in both debug and release mode
- sigpipe::reset() is the first statement in main()
- resolve_db_path() checks RTIK_DB env var, walks parents, falls back to cwd
- open_connection() sets WAL + synchronous=NORMAL before running migrations
- Schema has CHECK constraint on status, strftime UTC defaults on timestamps
- All module stubs (cli.rs, ticket.rs) compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-operations/01-01-SUMMARY.md`
</output>
